{"version":3,"sources":["components/Square.jsx","components/Button.jsx","components/Dijkstra.jsx","components/A-star.jsx","components/Greedy-BFS.jsx","components/Grid.jsx","components/App.jsx","index.js"],"names":["Square","props","className","onMouseOver","event","noDisturb","checkClick","isWall","target","style","backgroundColor","onMouseOut","squareColour","onClick","isSourceSet","isSinkSet","handleSquareClick","id","onMouseDown","setReadyForWall","createWall","onMouseEnter","onMouseUp","Button","buttonColour","colour","canClick","handleButtonClick","name","Dijkstra","tempGrid","updateGrid","rowCount","columnCount","markVisited","markExplored","markPath","setNoDisturb","setFoundPath","sourceRow","sourceColumn","sinkRow","sinkColumn","q","i","j","checkSource","distance","push","checkSink","row","col","curr","shift","setTimeout","rowIndex","colIndex","k","nr","nc","parent","isVisited","length","parRow","parColumn","Astar","start","end","dx","dy","dist","xxdist","prev","distRow","prevRow","xrow","Infinity","queue","sz","x1","y1","dis","index","temp","st","next","c","Math","abs","GreedyBestFirstSearch","isExplored","x2","y2","Grid","useState","setRandom","setSource","setSink","readyForWall","foundPath","grid","finalGrid","changeGrid","random","location","map","rowIdx","square","colIdx","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.89e80d41.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nfunction Square(props) {\r\n  function handleMouseOver(event) {\r\n    !props.noDisturb &&\r\n      !props.checkClick &&\r\n      !props.isWall &&\r\n      (event.target.style.backgroundColor = \"#77ACF1\");\r\n  }\r\n\r\n  function handleMouseOut(event) {\r\n    !props.noDisturb &&\r\n      !props.checkClick &&\r\n      !props.isWall &&\r\n      (event.target.style.backgroundColor = \"#FAF1E6\");\r\n  }\r\n\r\n  return (\r\n    <div\r\n      className=\"square\"\r\n      onMouseOver={handleMouseOver}\r\n      onMouseOut={handleMouseOut}\r\n      style={{ backgroundColor: props.squareColour }}\r\n      onClick={() =>\r\n        !props.noDisturb &&\r\n        (!props.isSourceSet || !props.isSinkSet) &&\r\n        props.handleSquareClick(props.id)\r\n      }\r\n      onMouseDown={() =>\r\n        props.isSourceSet &&\r\n        props.isSinkSet &&\r\n        props.setReadyForWall(true) &&\r\n        props.createWall(props.id)\r\n      }\r\n      onMouseEnter={() => props.createWall(props.id)}\r\n      onMouseUp={() =>\r\n        props.createWall(props.id) && props.setReadyForWall(false)\r\n      }\r\n    ></div>\r\n  );\r\n}\r\n\r\nexport default Square;\r\n","import React from \"react\";\r\n\r\nfunction Button(props) {\r\n  let buttonColour = props.colour;\r\n\r\n  return (\r\n    <div\r\n      className=\"button\"\r\n      onClick={() => props.canClick && props.handleButtonClick(props.colour)}\r\n      style={{ backgroundColor: buttonColour }}\r\n    >\r\n      {props.name}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Button;\r\n","function Dijkstra(\r\n  tempGrid,\r\n  updateGrid,\r\n  rowCount,\r\n  columnCount,\r\n  isSourceSet,\r\n  isSinkSet,\r\n  markVisited,\r\n  markExplored,\r\n  markPath,\r\n  setNoDisturb,\r\n  setFoundPath\r\n) {\r\n  if (!isSourceSet || !isSinkSet) {\r\n    return;\r\n  }\r\n\r\n  setNoDisturb(true);\r\n\r\n  let q = [];\r\n\r\n  let sourceRow, sourceColumn, sinkRow, sinkColumn;\r\n\r\n  for (let i = 0; i < rowCount; i++) {\r\n    for (let j = 0; j < columnCount; j++) {\r\n      if (tempGrid[i][j].checkSource) {\r\n        tempGrid[i][j].distance = 0;\r\n        q.push(tempGrid[i][j]);\r\n        sourceRow = i;\r\n        sourceColumn = j;\r\n      } else if (tempGrid[i][j].checkSink) {\r\n        sinkRow = i;\r\n        sinkColumn = j;\r\n      }\r\n    }\r\n  }\r\n\r\n  let row = [0, -1, 0, 1];\r\n  let col = [1, 0, -1, 0];\r\n\r\n  while (q.length !== 0) {\r\n    const curr = q.shift();\r\n    //Explore function\r\n\r\n    if (!curr.checkSource) {\r\n      setTimeout(() => markExplored(curr.rowIndex, curr.colIndex), 0);\r\n    }\r\n\r\n    for (let k = 0; k < 4; k++) {\r\n      let nr = curr.rowIndex + row[k];\r\n      let nc = curr.colIndex + col[k];\r\n\r\n      if (\r\n        nr < rowCount &&\r\n        nr >= 0 &&\r\n        nc < columnCount &&\r\n        nc >= 0 &&\r\n        !tempGrid[nr][nc].isWall &&\r\n        tempGrid[nr][nc].distance >\r\n          1 + tempGrid[curr.rowIndex][curr.colIndex].distance\r\n      ) {\r\n        tempGrid[nr][nc].parent.rowIndex = curr.rowIndex;\r\n        tempGrid[nr][nc].parent.colIndex = curr.colIndex;\r\n        tempGrid[nr][nc].distance =\r\n          1 + tempGrid[curr.rowIndex][curr.colIndex].distance;\r\n\r\n        if (!tempGrid[nr][nc].checkSink) {\r\n          setTimeout(\r\n            () =>\r\n              markVisited(tempGrid[nr][nc].rowIndex, tempGrid[nr][nc].colIndex),\r\n            0\r\n          );\r\n        } else {\r\n          tempGrid[nr][nc].isVisited = true;\r\n          break;\r\n        }\r\n        q.push(tempGrid[nr][nc]);\r\n      }\r\n    }\r\n\r\n    if (tempGrid[sinkRow][sinkColumn].isVisited) break;\r\n  }\r\n\r\n  while (q.length !== 0) {\r\n    let curr = q.shift();\r\n    setTimeout(() => markExplored(curr.rowIndex, curr.colIndex), 0);\r\n  }\r\n\r\n  let curr = tempGrid[sinkRow][sinkColumn];\r\n\r\n  while (curr.parent.rowIndex != null) {\r\n    let parRow = curr.parent.rowIndex,\r\n      parColumn = curr.parent.colIndex;\r\n\r\n    if (parRow === sourceRow && parColumn === sourceColumn) {\r\n      break;\r\n    }\r\n\r\n    setTimeout(() => markPath(parRow, parColumn), 0);\r\n\r\n    curr = tempGrid[parRow][parColumn];\r\n  }\r\n\r\n  setTimeout(() => setFoundPath(true), 0);\r\n}\r\n\r\nexport default Dijkstra;\r\n","function Astar(\r\n  tempGrid,\r\n  updateGrid,\r\n  rowCount,\r\n  columnCount,\r\n  isSourceSet,\r\n  isSinkSet,\r\n  markVisited,\r\n  markExplored,\r\n  markPath,\r\n  setNoDisturb,\r\n  setFoundPath\r\n) {\r\n  if (!isSourceSet || !isSinkSet) {\r\n    return;\r\n  }\r\n\r\n  setNoDisturb(true);\r\n\r\n  let sourceRow, sourceColumn, sinkRow, sinkColumn;\r\n\r\n  for (let i = 0; i < rowCount; i++) {\r\n    for (let j = 0; j < columnCount; j++) {\r\n      if (tempGrid[i][j].checkSource) {\r\n        tempGrid[i][j].distance = 0;\r\n        sourceRow = i;\r\n        sourceColumn = j;\r\n      } else if (tempGrid[i][j].checkSink) {\r\n        sinkRow = i;\r\n        sinkColumn = j;\r\n      }\r\n    }\r\n  }\r\n\r\n  const start = [sourceRow, sourceColumn],\r\n    end = [sinkRow, sinkColumn];\r\n  const dx = [0, 1, 0, -1],\r\n    dy = [1, 0, -1, 0];\r\n\r\n  function distance(x1, y1) {\r\n    return Math.abs(x1 - end[0]) + Math.abs(y1 - end[1]);\r\n  }\r\n\r\n  let dist = [],\r\n    xxdist = [],\r\n    prev = [];\r\n  for (let i = 0; i < rowCount; i++) {\r\n    let distRow = [],\r\n      prevRow = [],\r\n      xrow = [];\r\n    for (let j = 0; j < columnCount; j++) {\r\n      distRow.push(Infinity);\r\n      xrow.push(Infinity);\r\n      prevRow.push([i, j]);\r\n    }\r\n    dist.push(distRow);\r\n    xxdist.push(xrow);\r\n    prev.push(prevRow);\r\n  }\r\n\r\n  dist[start[0]][start[1]] = distance(start[0], start[1]);\r\n  xxdist[start[0]][start[1]] = 0;\r\n  let queue = [];\r\n  queue.push(start);\r\n  while (queue.length > 0) {\r\n    let sz = queue.length;\r\n    const [x1, y1] = queue[0];\r\n    let dis = dist[x1][y1];\r\n    let index = 0;\r\n    for (let j = 1; j < sz; j++) {\r\n      let [x1, y1] = queue[j];\r\n      if (dis > dist[x1][y1]) {\r\n        dis = dist[x1][y1];\r\n        index = j;\r\n      } else if (dis === dist[x1][y1]) {\r\n        let [x, y] = queue[index];\r\n        if (distance(x, y) > distance(x1, y1)) {\r\n          index = j;\r\n        }\r\n      }\r\n    }\r\n    let temp = queue[0];\r\n    queue[0] = queue[index];\r\n    queue[index] = temp;\r\n    let curr = queue.shift();\r\n\r\n    if (\r\n      !(\r\n        (sourceRow === curr[0] && sourceColumn === curr[1]) ||\r\n        (sinkRow === curr[0] && sinkColumn === curr[1])\r\n      )\r\n    )\r\n      setTimeout(() => markExplored(curr[0], curr[1]), 0);\r\n\r\n    if (curr[0] === end[0] && curr[1] === end[1]) {\r\n      curr = prev[curr[0]][curr[1]];\r\n      let st = [];\r\n      st.push(curr);\r\n      while (true) {\r\n        let temp = curr;\r\n        st.push(temp);\r\n        if (curr === start) {\r\n          for (let j = 0; j < st.length; j++) {\r\n            if (\r\n              !(\r\n                (sourceRow === st[j][0] && sourceColumn === st[j][1]) ||\r\n                (sinkRow === st[j][0] && sinkColumn === st[j][1])\r\n              )\r\n            )\r\n              setTimeout(() => markPath(st[j][0], st[j][1]), 0);\r\n          }\r\n          setTimeout(() => setFoundPath(true), 0);\r\n          return;\r\n        }\r\n        curr = prev[curr[0]][curr[1]];\r\n      }\r\n    }\r\n    for (let i = 0; i < 4; i++) {\r\n      let next = [curr[0] + dx[i], curr[1] + dy[i]];\r\n      if (\r\n        next[0] >= 0 &&\r\n        next[0] < rowCount &&\r\n        next[1] >= 0 &&\r\n        next[1] < columnCount &&\r\n        !tempGrid[next[0]][next[1]].isWall &&\r\n        !tempGrid[next[0]][next[1]].isVisited &&\r\n        dist[next[0]][next[1]] > 1 + dist[curr[0]][curr[1]]\r\n      ) {\r\n        queue.push(next);\r\n        prev[next[0]][next[1]] = curr;\r\n        xxdist[next[0]][next[1]] = xxdist[curr[0]][curr[1]] + 1;\r\n        let c = xxdist[next[0]][next[1]];\r\n        dist[next[0]][next[1]] = distance(next[0], next[1]) + c;\r\n\r\n        if (\r\n          !(\r\n            (sourceRow === next[0] && sourceColumn === next[1]) ||\r\n            (sinkRow === next[0] && sinkColumn === next[1])\r\n          )\r\n        )\r\n          setTimeout(() => markVisited(next[0], next[1]), 0);\r\n      }\r\n    }\r\n  }\r\n  setTimeout(() => setFoundPath(true), 0);\r\n}\r\n\r\nexport default Astar;\r\n","function GreedyBestFirstSearch(\r\n  tempGrid,\r\n  updateGrid,\r\n  rowCount,\r\n  columnCount,\r\n  isSourceSet,\r\n  isSinkSet,\r\n  markVisited,\r\n  markExplored,\r\n  markPath,\r\n  setNoDisturb,\r\n  setFoundPath\r\n) {\r\n  if (!isSourceSet || !isSinkSet) {\r\n    return;\r\n  }\r\n\r\n  setNoDisturb(true);\r\n\r\n  let sourceRow, sourceColumn, sinkRow, sinkColumn;\r\n\r\n  for (let i = 0; i < rowCount; i++) {\r\n    for (let j = 0; j < columnCount; j++) {\r\n      if (tempGrid[i][j].checkSource) {\r\n        tempGrid[i][j].distance = 0;\r\n        sourceRow = i;\r\n        sourceColumn = j;\r\n      } else if (tempGrid[i][j].checkSink) {\r\n        sinkRow = i;\r\n        sinkColumn = j;\r\n      }\r\n    }\r\n  }\r\n\r\n  const start = [sourceRow, sourceColumn],\r\n    end = [sinkRow, sinkColumn];\r\n  const dx = [0, 1, 0, -1],\r\n    dy = [1, 0, -1, 0];\r\n\r\n  function distance(x1, y1, x2, y2) {\r\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\r\n  }\r\n\r\n  let dist = [],\r\n    prev = [];\r\n  for (let i = 0; i < rowCount; i++) {\r\n    let distRow = [],\r\n      prevRow = [];\r\n    for (let j = 0; j < columnCount; j++) {\r\n      distRow.push(Infinity);\r\n      prevRow.push([i, j]);\r\n    }\r\n    dist.push(distRow);\r\n    prev.push(prevRow);\r\n  }\r\n\r\n  dist[start[0]][start[1]] = 0;\r\n\r\n  let queue = [];\r\n  queue.push(start);\r\n  while (queue.length > 0) {\r\n    let sz = queue.length;\r\n    const [x1, y1] = queue[0];\r\n    let dis = distance(x1, y1, end[0], end[1]);\r\n    let index = 0;\r\n    for (let j = 1; j < sz; j++) {\r\n      let [x1, y1] = queue[j];\r\n      if (dis > distance(x1, y1, end[0], end[1])) {\r\n        dis = distance(x1, y1, end[0], end[1]);\r\n        index = j;\r\n      }\r\n    }\r\n    let temp = queue[0];\r\n    queue[0] = queue[index];\r\n    queue[index] = temp;\r\n    let curr = queue.shift();\r\n\r\n    if (\r\n      !(\r\n        (sourceRow === curr[0] && sourceColumn === curr[1]) ||\r\n        (sinkRow === curr[0] && sinkColumn === curr[1])\r\n      )\r\n    )\r\n      setTimeout(() => markExplored(curr[0], curr[1]), 0);\r\n\r\n    if (curr[0] === end[0] && curr[1] === end[1]) {\r\n      curr = prev[curr[0]][curr[1]];\r\n      while (true) {\r\n        let temp = curr;\r\n        if (\r\n          !(\r\n            (sourceRow === temp[0] && sourceColumn === temp[1]) ||\r\n            (sinkRow === temp[0] && sinkColumn === temp[1])\r\n          )\r\n        )\r\n          setTimeout(() => markPath(temp[0], temp[1]), 0);\r\n        if (curr === start) {\r\n          setTimeout(() => setFoundPath(true), 0);\r\n          break;\r\n        }\r\n        curr = prev[curr[0]][curr[1]];\r\n      }\r\n      return;\r\n    }\r\n    for (let i = 0; i < 4; i++) {\r\n      let next = [curr[0] + dx[i], curr[1] + dy[i]];\r\n      if (\r\n        next[0] >= 0 &&\r\n        next[0] < rowCount &&\r\n        next[1] >= 0 &&\r\n        next[1] < columnCount &&\r\n        !tempGrid[next[0]][next[1]].isWall &&\r\n        !tempGrid[next[0]][next[1]].isVisited &&\r\n        !tempGrid[next[0]][next[1]].isExplored &&\r\n        dist[next[0]][next[1]] > 1 + dist[curr[0]][curr[1]]\r\n      ) {\r\n        queue.push(next);\r\n        prev[next[0]][next[1]] = curr;\r\n        dist[next[0]][next[1]] = 1 + dist[curr[0]][curr[1]];\r\n\r\n        if (\r\n          !(\r\n            (sourceRow === next[0] && sourceColumn === next[1]) ||\r\n            (sinkRow === next[0] && sinkColumn === next[1])\r\n          )\r\n        )\r\n          setTimeout(() => markVisited(next[0], next[1]), 0);\r\n      }\r\n    }\r\n  }\r\n  setTimeout(() => setFoundPath(true), 0);\r\n}\r\n\r\nexport default GreedyBestFirstSearch;\r\n","import React, { useState } from \"react\";\r\nimport Square from \"./Square\";\r\nimport Button from \"./Button\";\r\nimport Dijkstra from \"./Dijkstra\";\r\nimport Astar from \"./A-star\";\r\nimport GreedyBestFirstSearch from \"./Greedy-BFS\";\r\n\r\nfunction Grid() {\r\n  const [random, setRandom] = useState(0);\r\n  const [isSourceSet, setSource] = useState(false);\r\n  const [isSinkSet, setSink] = useState(false);\r\n  const [readyForWall, setReadyForWall] = useState(false);\r\n  const [noDisturb, setNoDisturb] = useState(false);\r\n  const [foundPath, setFoundPath] = useState(false);\r\n\r\n  let grid = [];\r\n  let rowCount = 17,\r\n    columnCount = 52;\r\n\r\n  for (let i = 0; i < rowCount; i++) {\r\n    let row = [];\r\n\r\n    for (let j = 0; j < columnCount; j++) {\r\n      let curr = {\r\n        rowIndex: i,\r\n        colIndex: j,\r\n        checkClick: false,\r\n        checkSource: false,\r\n        checkSink: false,\r\n        isWall: false,\r\n        isVisited: false,\r\n        parent: {\r\n          rowIndex: null,\r\n          colIndex: null,\r\n        },\r\n        distance: Infinity,\r\n        squareColour: \"#FAF1E6\",\r\n      };\r\n\r\n      if (i === 0 || j === 0 || i === rowCount - 1 || j === columnCount - 1) {\r\n        curr.isWall = true;\r\n        curr.squareColour = \"#125D98\";\r\n        curr.checkClick = true;\r\n      }\r\n\r\n      row.push(curr);\r\n    }\r\n\r\n    grid.push(row);\r\n  }\r\n\r\n  const [finalGrid, changeGrid] = useState(grid);\r\n\r\n  const updateGrid = (tempGrid) => {\r\n    changeGrid(tempGrid);\r\n    setRandom(Math.random());\r\n  };\r\n\r\n  function handleSquareClick(location) {\r\n    const { rowIndex: row, colIndex: col } = location;\r\n\r\n    let tempGrid = finalGrid;\r\n\r\n    for (let i = 1; i < rowCount - 1; i++) {\r\n      for (let j = 1; j < columnCount - 1; j++) {\r\n        if (i !== row || j !== col) {\r\n          if (\r\n            tempGrid[i][j].checkSource === false &&\r\n            tempGrid[i][j].checkSink === false &&\r\n            tempGrid[i][j].isWall === false\r\n          ) {\r\n            tempGrid[i][j].squareColour = \"#FAF1E6\";\r\n            tempGrid[i][j].checkClick = false;\r\n          }\r\n        } else {\r\n          if (!tempGrid[i][j].checkSource && !tempGrid[i][j].checkSink) {\r\n            tempGrid[row][col].checkClick = true;\r\n            tempGrid[row][col].squareColour = \"blue\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    updateGrid(tempGrid);\r\n    setRandom(Math.random());\r\n  }\r\n\r\n  function handleButtonClick(buttonColour) {\r\n    if (noDisturb) return;\r\n\r\n    buttonColour = buttonColour === \"#91BD3A\" ? \"green\" : \"red\";\r\n\r\n    let tempGrid = finalGrid;\r\n\r\n    for (let i = 0; i < rowCount; i++) {\r\n      for (let j = 0; j < columnCount; j++) {\r\n        if (tempGrid[i][j].squareColour === \"blue\") {\r\n          if (\r\n            (buttonColour === \"green\" && !isSourceSet) ||\r\n            (buttonColour === \"red\" && !isSinkSet)\r\n          ) {\r\n            tempGrid[i][j].squareColour = buttonColour;\r\n            tempGrid[i][j].checkSource = buttonColour === \"green\";\r\n            tempGrid[i][j].checkSink = buttonColour === \"red\";\r\n\r\n            if (buttonColour === \"green\") {\r\n              tempGrid[i][j].isVisited = true;\r\n              setSource(true);\r\n            } else setSink(true);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    updateGrid(tempGrid);\r\n    setRandom(Math.random());\r\n  }\r\n\r\n  function createWall(location) {\r\n    if (noDisturb || !readyForWall) {\r\n      return false;\r\n    }\r\n\r\n    const { rowIndex: row, colIndex: col } = location;\r\n\r\n    let tempGrid = finalGrid;\r\n\r\n    if (\r\n      !tempGrid[row][col].checkSource &&\r\n      !tempGrid[row][col].checkSink &&\r\n      tempGrid[row][col].squareColour === \"#FAF1E6\"\r\n    ) {\r\n      tempGrid[row][col].squareColour = \"#125D98\";\r\n      tempGrid[row][col].isWall = true;\r\n      updateGrid(tempGrid);\r\n      setRandom(Math.random());\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function markVisited(row, col) {\r\n    let tempGrid = finalGrid;\r\n    tempGrid[row][col].isVisited = true;\r\n    tempGrid[row][col].squareColour = \"#C68B59\";\r\n\r\n    updateGrid(tempGrid);\r\n    setRandom(Math.random());\r\n  }\r\n\r\n  function markExplored(row, col) {\r\n    let tempGrid = finalGrid;\r\n    tempGrid[row][col].squareColour = \"#C84B31\";\r\n\r\n    updateGrid(tempGrid);\r\n    setRandom(Math.random());\r\n  }\r\n\r\n  function markPath(row, col) {\r\n    let tempGrid = finalGrid;\r\n    tempGrid[row][col].squareColour = \"yellow\";\r\n\r\n    updateGrid(tempGrid);\r\n    setRandom(Math.random());\r\n  }\r\n\r\n  function resetGrid() {\r\n    if (noDisturb && !foundPath) return;\r\n\r\n    setNoDisturb(false);\r\n    setFoundPath(false);\r\n    setReadyForWall(false);\r\n    setSource(false);\r\n    setSink(false);\r\n    updateGrid(grid);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <div className=\"heading\">\r\n        <h1>Pathfinding Algorithms Visualizer</h1>\r\n      </div>\r\n\r\n      <div className=\"grid\">\r\n        {finalGrid.map((row, rowIdx) => {\r\n          return (\r\n            <div className=\"row\" key={rowIdx}>\r\n              {row.map((square, colIdx) => {\r\n                return (\r\n                  <Square\r\n                    key={[rowIdx, colIdx]}\r\n                    id={{\r\n                      rowIndex: rowIdx,\r\n                      colIndex: colIdx,\r\n                    }}\r\n                    squareColour={finalGrid[rowIdx][colIdx].squareColour}\r\n                    checkClick={finalGrid[rowIdx][colIdx].checkClick}\r\n                    handleSquareClick={handleSquareClick}\r\n                    isWall={finalGrid[rowIdx][colIdx].isWall}\r\n                    readyForWall={readyForWall}\r\n                    createWall={createWall}\r\n                    setReadyForWall={setReadyForWall}\r\n                    isSourceSet={isSourceSet}\r\n                    isSinkSet={isSinkSet}\r\n                    noDisturb={noDisturb}\r\n                  />\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n      <div className=\"button-group\">\r\n        <Button\r\n          name=\"Set Start Point\"\r\n          colour=\"#91BD3A\"\r\n          handleButtonClick={handleButtonClick}\r\n          canClick={!noDisturb}\r\n        />\r\n        <Button\r\n          name=\"Set End Point\"\r\n          colour=\"#FB3640\"\r\n          handleButtonClick={handleButtonClick}\r\n          canClick={!noDisturb}\r\n        />\r\n\r\n        <Button\r\n          name=\"Dijkstra Algorithm\"\r\n          colour=\"#FECD1A\"\r\n          handleButtonClick={() =>\r\n            Dijkstra(\r\n              finalGrid,\r\n              updateGrid,\r\n              rowCount,\r\n              columnCount,\r\n              isSourceSet,\r\n              isSinkSet,\r\n              markVisited,\r\n              markExplored,\r\n              markPath,\r\n              setNoDisturb,\r\n              setFoundPath\r\n            )\r\n          }\r\n          canClick={!noDisturb}\r\n        />\r\n\r\n        <Button\r\n          name=\"Greedy Best First Search Algorithm\"\r\n          colour=\"#FECD1A\"\r\n          handleButtonClick={() =>\r\n            GreedyBestFirstSearch(\r\n              finalGrid,\r\n              updateGrid,\r\n              rowCount,\r\n              columnCount,\r\n              isSourceSet,\r\n              isSinkSet,\r\n              markVisited,\r\n              markExplored,\r\n              markPath,\r\n              setNoDisturb,\r\n              setFoundPath\r\n            )\r\n          }\r\n          canClick={!noDisturb}\r\n        />\r\n\r\n        <Button\r\n          name=\"A* Algorithm\"\r\n          colour=\"#FECD1A\"\r\n          handleButtonClick={() =>\r\n            Astar(\r\n              finalGrid,\r\n              updateGrid,\r\n              rowCount,\r\n              columnCount,\r\n              isSourceSet,\r\n              isSinkSet,\r\n              markVisited,\r\n              markExplored,\r\n              markPath,\r\n              setNoDisturb,\r\n              setFoundPath\r\n            )\r\n          }\r\n          canClick={!noDisturb}\r\n        />\r\n\r\n        <Button\r\n          name=\"Reset Grid\"\r\n          colour=\"#D1D9D9\"\r\n          handleButtonClick={resetGrid}\r\n          canClick={!noDisturb || foundPath}\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Grid;\r\n","import React from \"react\";\nimport Grid from \"./Grid\";\n\nfunction App() {\n  return (\n    <div>\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./components/App\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}